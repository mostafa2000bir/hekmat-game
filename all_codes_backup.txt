import socketio
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.textinput import TextInput

sio = socketio.Client()

class HekmatClient(BoxLayout):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.orientation = 'vertical'
        self.padding = 50
        self.spacing = 20
        
        self.status_label = Label(text="ÙˆØ¶Ø¹ÛŒØª: Ù‚Ø·Ø¹ Ø§Ø±ØªØ¨Ø§Ø·", size_hint=(1, 0.2))
        self.add_widget(self.status_label)
        
        self.room_id_input = TextInput(hint_text="Ø´Ù†Ø§Ø³Ù‡ Ø§ØªØ§Ù‚", size_hint=(1, 0.1))
        self.add_widget(self.room_id_input)
        
        self.name_input = TextInput(hint_text="Ù†Ø§Ù… Ø¨Ø§Ø²ÛŒÚ©Ù†", size_hint=(1, 0.1))
        self.add_widget(self.name_input)
        
        self.connect_btn = Button(text="Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ±", size_hint=(1, 0.1))
        self.connect_btn.bind(on_press=self.connect_to_server)
        self.add_widget(self.connect_btn)
        
        self.create_btn = Button(text="Ø§ÛŒØ¬Ø§Ø¯ Ø§ØªØ§Ù‚", size_hint=(1, 0.1))
        self.create_btn.bind(on_press=self.create_room)
        self.add_widget(self.create_btn)
        
        self.join_btn = Button(text="Ù¾ÛŒÙˆØ³ØªÙ† Ø¨Ù‡ Ø§ØªØ§Ù‚", size_hint=(1, 0.1))
        self.join_btn.bind(on_press=self.join_room)
        self.add_widget(self.join_btn)
        
        self.start_btn = Button(text="Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ", size_hint=(1, 0.1))
        self.start_btn.bind(on_press=self.start_game)
        self.add_widget(self.start_btn)
        
        # ØªÙ†Ø¸ÛŒÙ… event handlers
        sio.on('connect', self.on_connect)
        sio.on('disconnect', self.on_disconnect)
        sio.on('room_created', self.on_room_created)
        sio.on('player_joined', self.on_player_joined)
        sio.on('game_started', self.on_game_started)
        sio.on('error', self.on_error)

    def connect_to_server(self, instance):
        try:
            sio.connect('http://127.0.0.1:5000')
            self.status_label.text = "Ø¯Ø± Ø­Ø§Ù„ Ø§ØªØµØ§Ù„..."
        except Exception as e:
            self.status_label.text = f"Ø®Ø·Ø§: {str(e)}"

    def create_room(self, instance):
        room_id = self.room_id_input.text
        player_name = self.name_input.text
        if room_id and player_name:
            sio.emit('create_room', {
                'room_id': room_id,
                'player_name': player_name
            })
        else:
            self.status_label.text = "Ù„Ø·ÙØ§Ù‹ Ø´Ù†Ø§Ø³Ù‡ Ø§ØªØ§Ù‚ Ùˆ Ù†Ø§Ù… Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"

    def join_room(self, instance):
        room_id = self.room_id_input.text
        player_name = self.name_input.text
        if room_id and player_name:
            sio.emit('join_room', {
                'room_id': room_id,
                'player_name': player_name
            })
        else:
            self.status_label.text = "Ù„Ø·ÙØ§Ù‹ Ø´Ù†Ø§Ø³Ù‡ Ø§ØªØ§Ù‚ Ùˆ Ù†Ø§Ù… Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"

    def start_game(self, instance):
        room_id = self.room_id_input.text
        if room_id:
            sio.emit('start_game', {'room_id': room_id})

    # Event handlers
    def on_connect(self):
        self.status_label.text = "Ù…ØªØµÙ„ Ø¨Ù‡ Ø³Ø±ÙˆØ±!"

    def on_disconnect(self):
        self.status_label.text = "Ù‚Ø·Ø¹ Ø§Ø±ØªØ¨Ø§Ø·"

    def on_room_created(self, data):
        self.status_label.text = f"Ø§ØªØ§Ù‚ {data['room_id']} Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯"

    def on_player_joined(self, data):
        self.status_label.text = f"{data['player_name']} Ù¾ÛŒÙˆØ³Øª"

    def on_game_started(self, data):
        self.status_label.text = "Ø¨Ø§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ø´Ø¯!"

    def on_error(self, data):
        self.status_label.text = f"Ø®Ø·Ø§: {data['message']}"

class HekmatApp(App):
    def build(self):
        return Hekmat
import random

class Card:
    def __init__(self, suit, value):
        self.suit = suit
        self.value = value

    def __str__(self):
        values = {1: 'Ace', 11: 'Jack', 12: 'Queen', 13: 'King'}
        value_name = values.get(self.value, str(self.value))
        return f"{value_name} of {self.suit}"

class Deck:
    def __init__(self):
        self.cards = []
        self.build()

    def build(self):
        suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']
        for suit in suits:
            for value in range(1, 14):
                self.cards.append(Card(suit, value))

    def shuffle(self):
        random.shuffle(self.cards)

    def deal(self, num_players):
        hands = [[] for _ in range(num_players)]
        for i in range(13):
            for j in range(num_players):
                if self.cards:
                    hands[j].append(self.cards.pop())
        return hands

def select_trump(players_hands):
    dealer = random.randint(0, 3)
    print(f"Player {dealer + 1} is the dealer and chooses trump.")
    
    print(f"Player {dealer + 1}'s first 5 cards:")
    for card in players_hands[dealer][:5]:
        print(" ", card)
    
    suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']
    trump_suit = random.choice(suits)
    print(f"Trump suit is: {trump_suit}")
    
    return dealer, trump_suit

def play_round(players_hands, trump_suit, starting_player):
    trick = []
    for i in range(4):
        player_index = (starting_player + i) % 4
        if players_hands[player_index]:
            card = random.choice(players_hands[player_index])
            players_hands[player_index].remove(card)
            trick.append((player_index, card))
            print(f"Player {player_index + 1} plays: {card}")
    
    winner_index = determine_winner(trick, trump_suit)
    print(f"Player {winner_index + 1} wins the trick!\n")
    return winner_index

def determine_winner(trick, trump_suit):
    winning_card = None
    winner_index = None
    for player_index, card in trick:
        if winning_card is None:
            winning_card = card
            winner_index = player_index
        else:
            if card.suit == trump_suit and winning_card.suit != trump_suit:
                winning_card = card
                winner_index = player_index
            elif card.suit == trump_suit and winning_card.suit == trump_suit:
                if card.value > winning_card.value:
                    winning_card = card
                    winner_index = player_index
            elif card.suit == trick[0][1].suit and winning_card.suit != trump_suit:
                if card.value > winning_card.value:
                    winning_card = card
                    winner_index = player_index
    return winner_index

def calculate_score(tricks_won):
    team1_tricks = tricks_won[0] + tricks_won[2]  # Players 1 and 3
    team2_tricks = tricks_won[1] + tricks_won[3]  # Players 2 and 4
    
    print(f"Team 1 (Players 1 & 3) won {team1_tricks} tricks.")
    print(f"Team 2 (Players 2 & 4) won {team2_tricks} tricks.")
    
    if team1_tricks > team2_tricks:
        print("Team 1 wins the game!")
    elif team2_tricks > team1_tricks:
        print("Team 2 wins the game!")
    else:
        print("It's a tie!")

# Ø§Ø¬Ø±Ø§ÛŒ Ø§ØµÙ„ÛŒ Ø¨Ø§Ø²ÛŒ
deck = Deck()
deck.shuffle()
players_hands = deck.deal(4)

dealer, trump_suit = select_trump(players_hands)

print("\n--- Starting the game ---")
current_player = dealer
tricks_won = [0, 0, 0, 0]  # ØªØ¹Ø¯Ø§Ø¯ Ø¯Ø³Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø¯Ù‡ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Ù‡Ø± Ø¨Ø§Ø²ÛŒÚ©Ù†

for trick_number in range(13):
    print(f"--- Trick {trick_number + 1} ---")
    winner_index = play_round(players_hands, trump_suit, current_player)
    tricks_won[winner_index] += 1
    current_player = winner_index

print("Game over!")
calculate_score(tricks_won)

import random

class Card:
    def __init__(self, suit, value):
        self.suit = suit
        self.value = value

    def __str__(self):
        values = {1: 'Ace', 11: 'Jack', 12: 'Queen', 13: 'King'}
        value_name = values.get(self.value, str(self.value))
        return f"{value_name} of {self.suit}"

class Deck:
    def __init__(self):
        self.cards = []
        self.build()

    def build(self):
        suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']
        for suit in suits:
            for value in range(1, 14):
                self.cards.append(Card(suit, value))

    def shuffle(self):
        random.shuffle(self.cards)

    def deal(self, num_players):
        hands = [[] for _ in range(num_players)]
        for i in range(13):
            for j in range(num_players):
                if self.cards:
                    hands[j].append(self.cards.pop())
        return hands

def select_trump(players_hands):
    # Ø§Ù†ØªØ®Ø§Ø¨ ØªØµØ§Ø¯ÙÛŒ Ø­Ø§Ú©Ù… (Ø¨Ø§Ø²ÛŒÚ©Ù† 0 ØªØ§ 3)
    dealer = random.randint(0, 3)
    print(f"Player {dealer + 1} is the dealer and chooses trump.")
    
    # Ù†Ù…Ø§ÛŒØ´ Ûµ Ú©Ø§Ø±Øª Ø§ÙˆÙ„ Ø­Ø§Ú©Ù… (Ø¨Ø±Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø­Ú©Ù…)
    print(f"Player {dealer + 1}'s first 5 cards:")
    for card in players_hands[dealer][:5]:
        print(" ", card)
    
    # Ø§Ù†ØªØ®Ø§Ø¨ Ø®Ø§Ù„ Ø­Ú©Ù… (ÙØ¹Ù„Ø§Ù‹ ØªØµØ§Ø¯ÙÛŒ)
    suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']
    trump_suit = random.choice(suits)
    print(f"Trump suit is: {trump_suit}")
    
    return dealer, trump_suit

# Ø§ØµÙ„ÛŒ
deck = Deck()
deck.shuffle()
players_hands = deck.deal(4)

dealer, trump_suit = select_trump(players_hands)

# Ù†Ù…Ø§ÛŒØ´ Ø¯Ø³Øª Ù‡Ù…Ù‡ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†
for i, hand in enumerate(players_hands):
    print(f"\nPlayer {i+1} has {len(hand)} cards:")
    for card in hand:
        print("  ", card)

import socketio
import time

sio = socketio.Client()

@sio.event
def connect():
    print("âœ… Ù…ØªØµÙ„ Ø¨Ù‡ Ø³Ø±ÙˆØ±!")

@sio.event
def disconnect():
    print("âŒ Ù‚Ø·Ø¹ Ø§Ø±ØªØ¨Ø§Ø·")

@sio.event
def player_joined(data):
    print(f"ğŸ¯ Ø¨Ø§Ø²ÛŒÚ©Ù† Ù¾ÛŒÙˆØ³Øª: {data['player_name']}")
    print(f"ğŸ‘¥ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†: {data['players']}")

@sio.event
def error(data):
    print(f"âŒ Ø®Ø·Ø§: {data['message']}")

def main():
    try:
        print("ğŸ”— Ø¯Ø± Ø­Ø§Ù„ Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ±...")
        sio.connect('http://127.0.0.1:5000')
        
        # Ù¾ÛŒÙˆØ³ØªÙ† Ø¨Ù‡ Ø§ØªØ§Ù‚ Ù…ÙˆØ¬ÙˆØ¯
        room_id = "test_room"  # Ù‡Ù…Ø§Ù† Ø§ØªØ§Ù‚ Ù‚Ø¨Ù„ÛŒ
        player_name = "Player2"  # Ù†Ø§Ù… Ù…ØªÙØ§ÙˆØª
        
        print(f"\nğŸ¯ Ù¾ÛŒÙˆØ³ØªÙ† Ø¨Ù‡ Ø§ØªØ§Ù‚: {room_id}")
        sio.emit('join_room', {
            'room_id': room_id,
            'player_name': player_name
        })
        
        # Ù†Ú¯Ù‡ Ø¯Ø§Ø´ØªÙ† Ø§ØªØµØ§Ù„
        print("\nâ³ Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§... (Ctrl+C Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬)")
        while True:
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Ø®Ø±ÙˆØ¬ Ø§Ø² Ø¨Ø±Ù†Ø§Ù…Ù‡")
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§: {e}")
    finally:
        sio.disconnect()

if __name__ == '__main__':
    main()
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.uix.image import Image
from kivy.clock import Clock
import random

class HekmatGame(BoxLayout):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.orientation = 'vertical'
        self.padding = 50
        self.spacing = 20
        
        # Ø¹Ù†ÙˆØ§Ù† Ø¨Ø§Ø²ÛŒ
        self.title_label = Label(
            text="Ø¨Ø§Ø²ÛŒ Ø­Ú©Ù…", 
            font_size=40,
            color=(1, 0.5, 0, 1)  # Ø±Ù†Ú¯ Ù†Ø§Ø±Ù†Ø¬ÛŒ
        )
        self.add_widget(self.title_label)
        
        # Ø¯Ú©Ù…Ù‡ Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ
        self.start_button = Button(
            text="Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯",
            size_hint=(1, 0.2),
            background_color=(0, 0.7, 0, 1)  # Ø±Ù†Ú¯ Ø³Ø¨Ø²
        )
        self.start_button.bind(on_press=self.start_game)
        self.add_widget(self.start_button)
        
        # ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒ
        self.status_label = Label(
            text="Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ...",
            font_size=20
        )
        self.add_widget(self.status_label)
    
    def start_game(self, instance):
        self.status_label.text = "Ø¨Ø§Ø²ÛŒ Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ Ø§Ø³Øª!\nØ¯Ø± Ø­Ø§Ù„ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§..."
        # Ø¨Ø¹Ø¯Ø§Ù‹ Ø§ÛŒÙ†Ø¬Ø§ Ù„Ø§Ú˜ÛŒÚ© Ø¨Ø§Ø²ÛŒ Ø±Ùˆ Ø§Ø¶Ø§ÙÙ‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…

class HekmatApp(App):
    def build(self):
        return HekmatGame()

if __name__ == '__main__':
    HekmatApp().run()
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.textinput import TextInput
import socketio

class HekmatOnlineClient(BoxLayout):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.orientation = 'vertical'
        self.sio = socketio.Client()
        self.setup_connection_handlers()
        
        # UI Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„
        self.room_id_input = TextInput(hint_text='Ø´Ù†Ø§Ø³Ù‡ Ø§ØªØ§Ù‚', size_hint=(1, 0.1))
        self.add_widget(self.room_id_input)
        
        self.connect_button = Button(text='Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø§ØªØ§Ù‚', size_hint=(1, 0.1))
        self.connect_button.bind(on_press=self.connect_to_room)
        self.add_widget(self.connect_button)
        
        self.status_label = Label(text='Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„...', size_hint=(1, 0.2))
        self.add_widget(self.status_label)

    def setup_connection_handlers(self):
        @self.sio.event
        def connect():
            self.status_label.text = 'Ù…ØªØµÙ„ Ø¨Ù‡ Ø³Ø±ÙˆØ±!'

        @self.sio.event
        def disconnect():
            self.status_label.text = 'Ù‚Ø·Ø¹ Ø§Ø±ØªØ¨Ø§Ø·!'

        @self.sio.event
        def room_created(data):
            self.status_label.text = f'Ø§ØªØ§Ù‚ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯: {data["room_id"]}'

        @self.sio.event
        def player_joined(data):
            self.status_label.text = f'Ø¨Ø§Ø²ÛŒÚ©Ù† Ù¾ÛŒÙˆØ³Øª: {data["player_name"]}'

    def connect_to_room(self, instance):
        room_id = self.room_id_input.text
        try:
            self.sio.connect('http://localhost:5000')
            self.sio.emit('join_room', {
                'room_id': room_id,
                'player_name': 'Player1'
            })
        except Exception as e:
            self.status_label.text = f'Ø®Ø·Ø§: {str(e)}'

class HekmatOnlineApp(App):
    def build(self):
        return HekmatOnlineClient()

if __name__ == '__main__':
    HekmatOnlineApp().run()
from flask import Flask
from flask_socketio import SocketIO, emit, join_room, leave_room
import random

app = Flask(__name__)
app.config['SECRET_KEY'] = 'hekmat_secret_key'
socketio = SocketIO(app, cors_allowed_origins="*")

# Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²ÛŒ
rooms = {}
players = {}

@socketio.on('connect')
def handle_connect():
    print('ÛŒÚ© Ú©Ù„Ø§ÛŒÙ†Øª Ù…ØªØµÙ„ Ø´Ø¯')
    emit('connected', {'message': 'Ø¨Ù‡ Ø³Ø±ÙˆØ± Ø­Ú©Ù… Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯!'})

@socketio.on('create_room')
def handle_create_room(data):
    room_id = data.get('room_id')
    player_name = data.get('player_name')
    
    if not room_id or not player_name:
        emit('error', {'message': 'Ø´Ù†Ø§Ø³Ù‡ Ø§ØªØ§Ù‚ ÛŒØ§ Ù†Ø§Ù… Ø¨Ø§Ø²ÛŒÚ©Ù† ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯'})
        return
    
    rooms[room_id] = {
        'players': [player_name],
        'game_state': 'waiting',
        'cards': [],
        'scores': {player_name: 0}
    }
    
    players[player_name] = room_id
    join_room(room_id)
    
    emit('room_created', {
        'room_id': room_id,
        'players': rooms[room_id]['players']
    }, room=room_id)
    
    print(f'Ø§ØªØ§Ù‚ {room_id} ØªÙˆØ³Ø· {player_name} Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯')

@socketio.on('join_room')
def handle_join_room(data):
    room_id = data.get('room_id')
    player_name = data.get('player_name')
    
    if not room_id or not player_name:
        emit('error', {'message': 'Ø´Ù†Ø§Ø³Ù‡ Ø§ØªØ§Ù‚ ÛŒØ§ Ù†Ø§Ù… Ø¨Ø§Ø²ÛŒÚ©Ù† ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯'})
        return
    
    if room_id not in rooms:
        emit('error', {'message': 'Ø§ØªØ§Ù‚ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯'})
        return
    
    if player_name in rooms[room_id]['players']:
        emit('error', {'message': 'Ø§ÛŒÙ† Ù†Ø§Ù… Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡'})
        return
    
    rooms[room_id]['players'].append(player_name)
    rooms[room_id]['scores'][player_name] = 0
    players[player_name] = room_id
    join_room(room_id)
    
    emit('player_joined', {
        'player_name': player_name,
        'players': rooms[room_id]['players']
    }, room=room_id)
    
    print(f'{player_name} Ø¨Ù‡ Ø§ØªØ§Ù‚ {room_id} Ù¾ÛŒÙˆØ³Øª')

@socketio.on('start_game')
def handle_start_game(data):
    room_id = data.get('room_id')
    
    if room_id not in rooms:
        emit('error', {'message': 'Ø§ØªØ§Ù‚ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯'})
        return
    
    rooms[room_id]['game_state'] = 'playing'
    
    # ØªÙˆØ²ÛŒØ¹ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ (Ø§ÛŒÙ†Ø¬Ø§ Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒÙ… Ù…Ù†Ø·Ù‚ Ú©Ø§Ù…Ù„ Ø±Ùˆ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒÙ…)
    emit('game_started', {
        'message': 'Ø¨Ø§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ø´Ø¯!',
        'players': rooms[room_id]['players']
    }, room=room_id)
    
    print(f'Ø¨Ø§Ø²ÛŒ Ø¯Ø± Ø§ØªØ§Ù‚ {room_id} Ø´Ø±ÙˆØ¹ Ø´Ø¯')

if __name__ == '__main__':
    print('ğŸš€ Ø³Ø±ÙˆØ± Ø¨Ø§Ø²ÛŒ Ø­Ú©Ù… Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ Ø±ÙˆÛŒ Ù¾ÙˆØ±Øª 5000...')
    socketio.run(app, host='0.0.0.0', port=5000, debug=True)
from setuptools import setup; setup()
import socketio
import time

sio = socketio.Client()

@sio.event
def connect():
    print("âœ… Ù…ØªØµÙ„ Ø¨Ù‡ Ø³Ø±ÙˆØ±!")

@sio.event
def disconnect():
    print("âŒ Ù‚Ø·Ø¹ Ø§Ø±ØªØ¨Ø§Ø·")

@sio.event
def room_created(data):
    print(f"ğŸ‰ Ø§ØªØ§Ù‚ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯: {data['room_id']}")
    print(f"ğŸ‘¥ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†: {data['players']}")

@sio.event
def player_joined(data):
    print(f"ğŸ¯ Ø¨Ø§Ø²ÛŒÚ©Ù† Ù¾ÛŒÙˆØ³Øª: {data['player_name']}")
    print(f"ğŸ‘¥ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†: {data['players']}")

@sio.event
def game_started(data):
    print("ğŸš€ Ø¨Ø§Ø²ÛŒ Ø´Ø±ÙˆØ¹ Ø´Ø¯!")
    print(f"ğŸ‘¥ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†: {data['players']}")

@sio.event
def error(data):
    print(f"âŒ Ø®Ø·Ø§: {data['message']}")

def main():
    try:
        print("ğŸ”— Ø¯Ø± Ø­Ø§Ù„ Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø³Ø±ÙˆØ±...")
        sio.connect('http://127.0.0.1:5000')
        
        # ØªØ³Øª Ø§ÛŒØ¬Ø§Ø¯ Ø§ØªØ§Ù‚
        room_id = "test_room"
        player_name = "Player1"
        
        print(f"\nğŸ¯ Ø§ÛŒØ¬Ø§Ø¯ Ø§ØªØ§Ù‚: {room_id}")
        sio.emit('create_room', {
            'room_id': room_id,
            'player_name': player_name
        })
        
        # Ù†Ú¯Ù‡ Ø¯Ø§Ø´ØªÙ† Ø§ØªØµØ§Ù„
        print("\nâ³ Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§... (Ctrl+C Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬)")
        while True:
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Ø®Ø±ÙˆØ¬ Ø§Ø² Ø¨Ø±Ù†Ø§Ù…Ù‡")
    except Exception as e:
        print(f"âŒ Ø®Ø·Ø§: {e}")
    finally:
        sio.disconnect()

if __name__ == '__main__':
    main()
